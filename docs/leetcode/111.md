---
date: 2024-01-02
categories:
  - LeetCode
search:
  boost: 2
hide:
  - footer
---

[https://leetcode.cn/problems/minimum-depth-of-binary-tree/](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

## 题目

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明：叶子节点是指没有子节点的节点。

示例 1:

![](../assets/img/leetcode/111.jpeg){ width="40%"}

> 输入：root = [3,9,20,null,null,15,7]

> 输出：2

示例 2:

> 输入：root = [2,null,3,null,4,null,5,null,6]

> 输出：5

## 复杂度

双指针+虚拟头结点

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

## 题解

```go title="Go"
func minDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }

    if root.Left == nil && root.Right != nil {
        return 1 + minDepth(root.Right)
    }

    if root.Left != nil && root.Right == nil {
        return 1 + minDepth(root.Left)
    }

    return 1 + min(minDepth(root.Right), minDepth(root.Left))
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

```python title="Python"
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if root == None:
            return 0

        if root.left == None and root.right != None:
            return 1 + self.minDepth(root.right)

        if root.left != None and root.right == None:
            return 1 + self.minDepth(root.left)

        return 1 + min(self.minDepth(root.right), self.minDepth(root.left))
```
