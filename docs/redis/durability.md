---
date: 2024-02-02
categories:
  - Redis
search:
  boost: 2
hide:
  - footer
---

Redis 共有三种数据持久化的方式：

- **AOF 日志**：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；
- **RDB 快照**：将某一时刻的内存数据，以二进制的方式写入磁盘；
- **混合持久化方式**：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点

## AOF 日志

Reids 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做其实有两个好处。

**好处**

- **避免额外的检查开销**：因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。
- **不会阻塞当前写操作命令的执行**：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。

**风险**

- **数据可能会丢失**： 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。
- **可能阻塞其他操作**： 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。

### Redis 写入 AOF 日志的过程

![](../assets/img/redis/redis_aof_log.webp)

1. Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；
2. 然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；
3. 具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。

### 写回（写回硬盘）策略

| 写回策略 |      写回时机      |               优点               |                缺点                |
| :------: | :----------------: | :------------------------------: | :--------------------------------: |
|  Always  |      同步写回      | 可靠性高、最大程度保证数据不丢失 | 每个写命令都要写回硬盘，性能开销大 |
| Everysec |      每秒写回      |             性能适中             |     宕机时会丢弃 1 秒内的数据      |
|    No    | 由操作系统控制写回 |              性能好              |     宕机时丢失的数据可能会很多     |

- 如果要高性能，就选择 No 策略；
- 如果要高可靠，就选择 Always 策略；
- 如果允许数据丢失一点，但又想性能高，就选择 Everysec 策略。

### AOF 重写机制

Redis 为了避免 AOF 文件越写越大，提供了 AOF 重写机制，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。

重写机制的妙处在于，尽管某个键值对被多条写命令反复修改，**最终也只需要根据这个「键值对」当前的最新状态，然后用一条命令去记录键值对**，代替之前记录这个键值对的多条命令，这样就减少了 AOF 文件中的命令数量。最后在重写工作完成后，将新的 AOF 文件覆盖现有的 AOF 文件。

### AOF 后台重写

Redis 的重写 AOF 过程是由后台子进程 **bgrewriteaof** 来完成的

- 子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；
- 子进程带有主进程的数据副本（数据副本怎么产生的后面会说），这里使用子进程而不是线程

子进程就共享了父进程的物理内存数据了，这样能够节约物理内存资源，页表对应的页表项的属性会标记该物理内存的权限为只读。

!!!note "写时复制(Copy On Write)"

    当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发**写保护中断**，这个写保护中断是由于违反权限导致的，然后操作系统会在「写保护中断处理函数」里进行**物理内存的复制**，并重新设置其内存映射关系，将父子进程的内存读写权限设置为**可读写**，**最后才会对内存进行写操作**，这个过程被称为**「写时复制(Copy On Write)」**。

![](../assets/img/redis/bgrewriteaof.webp)

在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:

1. 执行客户端发来的命令；
2. 将执行后的写命令追加到 「AOF 缓冲区」；
3. 将执行后的写命令追加到 「AOF 重写缓冲区」；

{==

在整个 AOF 后台重写过程中，除了发生**写时复制**会对主进程造成阻塞，还有**信号处理函数**执行时也会对主进程**造成阻塞**，在其他时候，AOF 后台重写都不会阻塞主进程。

==}

## RDB 快照

**RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据**，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。

因此**在 Redis 恢复数据时**， RDB 恢复数据的效率会比 AOF 高些，因为**直接将 RDB 文件读入内存**就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。

Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的**区别就在于是否在「主线程」里执行**：

- 执行了 save 命令，**就会在主线程生成 RDB 文件**，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，**会阻塞主线程**；
- 执行了 bgsave 命令，会**创建一个子进程来生成 RDB 文件**，这样可以**避免主线程的阻塞**；

!!!tip

    Redis 的快照是**全量快照**，也就是说每次执行快照，都是**把内存中的「所有数据」都记录到磁盘中**。

!!!question "RDB 在执行快照的时候，数据能修改吗？"

    **可以的**，执行 bgsave 过程中，Redis 依然**可以继续处理操作命令的**，也就是数据是能被修改的，关键的技术就在于**写时复制技术（Copy-On-Write, COW）**。

## 混合持久化

- RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。
- AOF 优点是丢失数据少，但是数据恢复不快。

为了集成了两者的优点， Redis 4.0 提出了**混合使用 AOF 日志和内存快照**，也叫混合持久化，**既保证了 Redis 重启速度，又降低数据丢失风险**。

使用了混合持久化，AOF 文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据。

**混合持久化优点：**

- 混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。

**混合持久化缺点：**

- AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；
- 兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。

---
## 参考
- [小林 coding - 图解 Redis：持久化篇](https://xiaolincoding.com/redis/storage/aof.html)
