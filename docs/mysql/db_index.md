---
date: 2024-01-02
categories:
  - MySQL
search:
  boost: 2
hide:
  - footer
---

## 什么是索引？

索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。

## 索引的分类

- 按**「数据结构」**分类：**B+tree 索引、Hash 索引、Full-text 索引**。
- 按**「物理存储」**分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。
- 按**「字段特性」**分类：**主键索引、唯一索引、普通索引、前缀索引**。
- 按**「字段个数」**分类：**单列索引、联合索引**。

在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：

- 如果有主键，默认会使用主键作为聚簇索引的索引键（key）；
- 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；
- 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；

其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。**创建的主键索引和二级索引默认使用的是 B+Tree 索引。**

!!!note "联合索引的最左匹配原则"

    在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配，

## 什么时候适用索引？

- **字段有唯一性限制的**，比如商品编码；
- **经常用于 WHERE 查询条件的字段**，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
- **经常用于 GROUP BY 和 ORDER BY 的字段**，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。

## 什么时候不需要创建索引？

- WHERE 条件，GROUP BY 和 ORDER BY 里用不到的字段
- 字段中存在**大量重复数据**，不需要创建索引
- **表数据太少**，不需要创建索引
- **经常更新的字段**不用创建索引

## 优化索引的方法

- 前缀索引优化；
- 覆盖索引优化；
- 主键索引最好是自增的；
- 防止索引失效；

### 前缀索引优化

**前缀索引：使用 ==某个字段中字符串的前几个字符== 建立索引**。

使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。

!!!note "前缀索引有一定的局限性"

    - `order by` 就无法使用前缀索引
    - 无法把前缀索引用作覆盖索引

### 覆盖索引优化

覆盖索引（covering index ，或称为索引覆盖）即从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。

使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。

!!!question "如何确定数据库成功使用了覆盖索引呢？"

    当发起一个索引覆盖查询时，在 explain 的 extra 列可以看到 using index 的信息。Extra中 `Using index` 表明我们成功使用了覆盖索引。

### 主键索引最好是自增的

**InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上**。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。

如果使用费自增主键，每次插入主键的索引值都是随机的。导致**出现页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。**

### 防止索引失效

避免写出索引失效的查询语句。以下情况会发生索引失效的情况：

- 当使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%` 这两种方式都会造成索引失效；
- 当在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；
- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

## 索引下推

索引下推（Index Condition Pushdown） 是 MySQL 5.6 版本中提供的一项索引优化功能，可以**在非聚簇索引(联合索引)遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。**

{==

当你的查询语句的执行计划里，出现了 Extra 为 `Using index condition`，那么说明使用了索引下推的优化。

==}

## 为什么 MySQL 采用 B+ 树作为索引？

InnoDB 是 MySQL 默认的存储引擎，它就是采用了 B+ 树作为索引的数据结构。

1. B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 **B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O 次数会更少**。
2. **B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高**，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；
3. **B+ 树叶子节点之间用链表连接了起来，有利于范围查询**，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。

## count(\*) 和 count(1) 有什么区别？哪个性能最好？

按照性能排序：`count(*) = count(1) > count(主键字段) > count(字段)`

count(1)、 count(\*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。

**如果要执行 count(1)、 count(\*)、 count(主键字段) 时，尽量在数据表上建立二级索引**，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。

就是**不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计**。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。

### 如何优化 count(\*)？

- 近似值：可以使用 ` show table status`` 或者  `explain`` 命令来表进行估算。
- 额外表保存计数值：想精确的获取表的记录总数，可以将这个计数值保存到单独的一张计数表中

---

## 参考
- [小林 coding-索引常见面试题](https://xiaolincoding.com/mysql/index/index_interview.html)
