---
date: 2024-01-02
categories:
  - General
search:
  boost: 2
---

## Redis 过期删除策略有哪些？

1. **定时删除**：对内存是最友好的。对 CPU 不友好。
      1. **优点**：可以保证过期 key 会被尽快删除，也就是内存可以被尽快地释放。
      2. **缺点**：在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。
2. **惰性删除**：对内存是最友好的。对 CPU 不友好。
3. **定期删除**：对是 CPU 最友好的。对 内存 不友好。

!!!question "定时删除策略是怎么样的？"
    
    定时删除策略的做法是，在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。

!!!question "惰性删除策略是怎么样的？"

    惰性删除策略的做法是，不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。


!!!question "定期删除策略是怎么样的？"

    定期删除策略的做法是，每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。

{==

Redis 选择 **「惰性删除+定期删除」**这两种策略配和使用，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。

==}

## Redis 内存淘汰策略

在配置文件 `redis.conf` 中，可以通过参数 `maxmemory <bytes>` 来设定最大运行内存，只有在 Redis 的运行内存达到了我们设置的最大运行内存，才会触发内存淘汰策略


Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。

### 不进行数据淘汰的策略

**noeviction**（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，会报错通知禁止写入，不淘汰任何数据，但是如果没用数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作。

### 进行数据淘汰的策略

针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。

在设置了过期时间的数据中进行淘汰：

- **volatile-random**：随机淘汰设置了过期时间的任意键值；
- **volatile-ttl**：优先淘汰更早过期的键值。
- **volatile-lru**（Redis 3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；
- **volatile-lfu**（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；

在所有数据范围内进行淘汰：

- **allkeys-random**：随机淘汰任意键值;
- **allkeys-lru**：淘汰整个键值中最久未使用的键值；
- **allkeys-lfu**（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。

!!!note "如何查看当前Redis使用的内存淘汰策略？"

    ``` bash
    127.0.0.1:6379> config get maxmemory-policy
    1) "maxmemory-policy"
    2) "noeviction"
    ```

!!!note "如何修改当前Redis使用的内存淘汰策略？"

    - 方式一：通过 `#!bash config set maxmemory-policy <策略>` 命令设置。
        - 优点：设置之后立即生效，不需要重启 Redis 服务；缺点：重启 Redis 之后，设置就会失效。
    - 方式二：通过修改 Redis 配置文件修改，设置 `#!bash maxmemory-policy <策略>`
        - 优点：重启 Redis 服务后配置不会丢失；缺点：必须重启 Redis 服务，设置才能生效。


[^1]: [图解Redis介绍](https://xiaolincoding.com/redis/)
